"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.waitForPrediction=waitForPrediction;exports.handlePredictionError=handlePredictionError;exports.extractAudioUrl=extractAudioUrl;const logger_1=require("../../../../utils/logger");async function waitForPrediction(r,e,t=false){try{let o=e;const i=Date.now();const n=6e4;while("succeeded"!==o.status&&"failed"!==o.status){if(Date.now()-i>n)throw new Error("Prediction timeout after 60 seconds");await new Promise(r=>setTimeout(r,1e3));try{o=await r.predictions.get(o.id)}catch(r){logger_1.logger.error("Error fetching prediction status:",r);throw new Error(`Failed to get prediction status: ${r instanceof Error?r.message:"Unknown error"}`)}if(t);}return o}catch(r){logger_1.logger.error("Error waiting for prediction:",r);throw r}}async function handlePredictionError(r,e,t,o,i=false){try{const n=r;const s=n.error||"Unknown error";logger_1.logger.error("[MinimaxTTS] Prediction failed:",{id:n.id,error:String(s),logs:n.logs});if(i&&n.logs);if(["Service is temporarily unavailable","E004","rate limit","timeout","temporary","connection","network"].some(r=>String(s).toLowerCase().includes(r.toLowerCase()))&&e<t-1){await new Promise(r=>setTimeout(r,o));return true}throw new Error(`Prediction failed: ${String(s)}`)}catch(r){logger_1.logger.error("Error handling prediction error:",r);throw r}}function extractAudioUrl(r){if(Array.isArray(r)&&r.length>0)return r[0];else if("string"===typeof r)return r;else if(r&&"object"===typeof r){const e=r;const t=e.url||e.audio_url||e.output||r;if("string"!==typeof t)throw new Error(`Could not find audio URL in output: ${JSON.stringify(r)}`);return t}else throw new Error("Unexpected output format from model: "+typeof r)}