"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.ExecutionStrategies=void 0;const nodes_1=require("../../nodes/index"),logger_1=require("../../../utils/logger");class ExecutionStrategies{nodeIOManager;progressTracker;constructor(e,t){this.nodeIOManager=e,this.progressTracker=t}async executeSequential(e){const{executionOrder:t,signal:r,result:o}=e;for(let s=0;s<t.length;s++){if(r.aborted){"running"===o.status&&(o.status="cancelled");break}const n=t[s];await this.executeNode(n,e,s)}}async executeNode(e,t,r){const{nodeInstances:o,workflow:s,nodeOutputs:n,initialInput:a,context:i,result:d,options:c,signal:l}=t,u=o.get(e);if(!u)throw new Error(`Node ${e} not found`);const g=d.nodeStatuses.get(e);if(!g)throw new Error(`Node status not found for ${e}`);g.startTime=new Date,g.state=nodes_1.NodeState.VALIDATING;try{const o=await this.nodeIOManager.gatherAndTransformInputs(e,s,n,a,u);g.state=nodes_1.NodeState.EXECUTING,g.progress=0,this.progressTracker.sendProgressUpdate(d.executionId,d.progress,d.nodeStatuses);const p=await this.executeNodeWithProgress({node:u,nodeInput:o,context:i,nodeId:e,nodeStatus:g,result:d,options:c,signal:l,nodeIndex:r,totalNodes:t.executionOrder.length});if(g.endTime=new Date,g.result=p,g.state=u.getState(),g.progress=u.getProgress(),d.nodeResults.set(e,p),this.progressTracker.sendProgressUpdate(d.executionId,d.progress,d.nodeStatuses),p.success&&p.data){n.set(e,p.data),logger_1.logger.debug(`[WORKFLOW] Stored output for node ${e} (${u.getType()})`);const t=u.getType();this.progressTracker.sendNodeOutput(d.executionId,e,t,p.data)}else if(!c.continueOnError)throw logger_1.logger.error(`[WORKFLOW] Node ${e} FAILED:`,p.error),new Error(`Node ${e} failed: ${p.error}`)}catch(e){if(l.aborted?(g.state=nodes_1.NodeState.CANCELLED,g.error="Node cancelled"):(g.error=e instanceof Error?e.message:"Unknown error",g.state=nodes_1.NodeState.FAILED),g.endTime=new Date,!c.continueOnError)throw e}}async executeNodeWithProgress(e){const{node:t,nodeInput:r,context:o,nodeId:s,nodeStatus:n,result:a,options:i,signal:d,nodeIndex:c,totalNodes:l}=e;if(d.aborted)throw new Error("Workflow cancelled");let u=null;for(let e=1;e<=3;e++)try{return await t.executeWithStateTracking(r,{...o,nodeId:s,signal:d},async e=>{try{if(d.aborted)throw new Error("Workflow cancelled");n.progress=e,void 0!==c&&l&&(a.progress=(c+e/100)/l*100),i.onProgress&&i.onProgress(a.executionId,a.progress,a.nodeStatuses),this.progressTracker.sendProgressUpdate(a.executionId,a.progress,a.nodeStatuses),await new Promise(e=>setImmediate(e))}catch(e){throw logger_1.logger.error("Error in progress callback:",e),e}})}catch(t){u=t;if(!this.isRetryableError(t)||3===e)throw t;const r=this.getRetryDelay(t,e);logger_1.logger.warn(`Node ${s} failed with retryable error, retrying in ${r}ms (attempt ${e}/3)`,t),await new Promise(e=>setTimeout(e,r))}throw u||new Error("Unexpected retry logic error")}isRetryableError(e){if(!(e instanceof Error))return!1;const t=e;if("RATE_LIMIT_ERROR"===t.code)return!0;if("ETIMEDOUT"===t.code||"ECONNRESET"===t.code||"ECONNREFUSED"===t.code)return!0;const r=e.message.toLowerCase();return!!(r.includes("rate limit")||r.includes("timeout")||r.includes("network"))}getRetryDelay(e,t){const r=e;return r.retryAfter?r.retryAfter:Math.min(100*Math.pow(2,t-1),1e3)}async executeParallel(e){const{executionOrder:t,workflow:r,signal:o,result:s}=e,n=this.groupNodesByLevel(t,r);for(const t of n){if(o.aborted){"running"===s.status&&(s.status="cancelled");break}const r=(await Promise.allSettled(t.map(t=>this.executeNode(t,e)))).filter(e=>"rejected"===e.status);if(r.length>0&&!e.options.continueOnError){if(o.aborted)throw new Error("Workflow cancelled");throw r[0].reason}}}groupNodesByLevel(e,t){const r=[],o=new Map;for(const s of e){const e=t.edges.filter(e=>e.target===s).map(e=>e.source),n=(0===e.length?-1:Math.max(...e.map(e=>o.get(e)||0)))+1;o.set(s,n),r[n]||(r[n]=[]),r[n].push(s)}return r.filter(e=>e&&e.length>0)}}exports.ExecutionStrategies=ExecutionStrategies;