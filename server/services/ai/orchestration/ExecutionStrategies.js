"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.ExecutionStrategies=void 0;const nodes_1=require("../../nodes/index");const logger_1=require("../../../utils/logger");class ExecutionStrategies{nodeIOManager;progressTracker;constructor(e,t){this.nodeIOManager=e;this.progressTracker=t}async executeSequential(e){const{executionOrder:t,signal:r,result:o}=e;for(let s=0;s<t.length;s++){if(r.aborted){if("running"===o.status)o.status="cancelled";break}const n=t[s];await this.executeNode(n,e,s)}}async executeNode(e,t,r){const{nodeInstances:o,workflow:s,nodeOutputs:n,initialInput:a,context:i,result:d,options:c,signal:u}=t;const l=o.get(e);if(!l)throw new Error(`Node ${e} not found`);const g=d.nodeStatuses.get(e);if(!g)throw new Error(`Node status not found for ${e}`);g.startTime=new Date;g.state=nodes_1.NodeState.VALIDATING;try{const o=await this.nodeIOManager.gatherAndTransformInputs(e,s,n,a,l);g.state=nodes_1.NodeState.EXECUTING;g.progress=0;this.progressTracker.sendProgressUpdate(d.executionId,d.progress,d.nodeStatuses);const f=await this.executeNodeWithProgress({node:l,nodeInput:o,context:i,nodeId:e,nodeStatus:g,result:d,options:c,signal:u,nodeIndex:r,totalNodes:t.executionOrder.length});g.endTime=new Date;g.result=f;g.state=l.getState();g.progress=l.getProgress();d.nodeResults.set(e,f);this.progressTracker.sendProgressUpdate(d.executionId,d.progress,d.nodeStatuses);if(f.success&&f.data){n.set(e,f.data);logger_1.logger.debug(`[WORKFLOW] Stored output for node ${e} (${l.getType()})`);const t=l.getType();this.progressTracker.sendNodeOutput(d.executionId,e,t,f.data)}else if(!c.continueOnError){logger_1.logger.error(`[WORKFLOW] Node ${e} FAILED:`,f.error);throw new Error(`Node ${e} failed: ${f.error}`)}}catch(e){if(u.aborted){g.state=nodes_1.NodeState.CANCELLED;g.error="Node cancelled"}else{g.error=e instanceof Error?e.message:"Unknown error";g.state=nodes_1.NodeState.FAILED}g.endTime=new Date;if(!c.continueOnError)throw e}}async executeNodeWithProgress(e){const{node:t,nodeInput:r,context:o,nodeId:s,nodeStatus:n,result:a,options:i,signal:d,nodeIndex:c,totalNodes:u}=e;if(d.aborted)throw new Error("Workflow cancelled");let l=null;for(let e=1;e<=3;e++)try{return await t.executeWithStateTracking(r,{...o,nodeId:s,signal:d},async e=>{try{if(d.aborted)throw new Error("Workflow cancelled");n.progress=e;if(void 0!==c&&u)a.progress=(c+e/100)/u*100;if(i.onProgress)i.onProgress(a.executionId,a.progress,a.nodeStatuses);this.progressTracker.sendProgressUpdate(a.executionId,a.progress,a.nodeStatuses);await new Promise(e=>setImmediate(e))}catch(e){logger_1.logger.error("Error in progress callback:",e);throw e}})}catch(t){l=t;if(!this.isRetryableError(t)||3===e)throw t;const r=this.getRetryDelay(t,e);logger_1.logger.warn(`Node ${s} failed with retryable error, retrying in ${r}ms (attempt ${e}/3)`,t);await new Promise(e=>setTimeout(e,r))}throw l||new Error("Unexpected retry logic error")}isRetryableError(e){if(!(e instanceof Error))return false;const t=e;if("RATE_LIMIT_ERROR"===t.code)return true;if("ETIMEDOUT"===t.code||"ECONNRESET"===t.code||"ECONNREFUSED"===t.code)return true;const r=e.message.toLowerCase();if(r.includes("rate limit")||r.includes("timeout")||r.includes("network"))return true;return false}getRetryDelay(e,t){const r=e;if(r.retryAfter)return r.retryAfter;return Math.min(100*Math.pow(2,t-1),1e3)}async executeParallel(e){const{executionOrder:t,workflow:r,signal:o,result:s}=e;const n=this.groupNodesByLevel(t,r);for(const t of n){if(o.aborted){if("running"===s.status)s.status="cancelled";break}const r=(await Promise.allSettled(t.map(t=>this.executeNode(t,e)))).filter(e=>"rejected"===e.status);if(r.length>0&&!e.options.continueOnError){if(o.aborted)throw new Error("Workflow cancelled");throw r[0].reason}}}groupNodesByLevel(e,t){const r=[];const o=new Map;for(const s of e){const e=t.edges.filter(e=>e.target===s).map(e=>e.source);const n=(0===e.length?-1:Math.max(...e.map(e=>o.get(e)||0)))+1;o.set(s,n);if(!r[n])r[n]=[];r[n].push(s)}return r.filter(e=>e&&e.length>0)}}exports.ExecutionStrategies=ExecutionStrategies;