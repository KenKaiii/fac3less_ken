"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.WorkflowExecutor=void 0;const nodes_1=require("../../nodes/index"),WorkflowValidator_1=require("./WorkflowValidator"),ProgressTracker_1=require("./ProgressTracker"),NodeIOManager_1=require("./NodeIOManager"),ExecutionStrategies_1=require("./ExecutionStrategies"),ExecutionManager_1=require("./ExecutionManager"),logger_1=require("../../../utils/logger");class WorkflowExecutor{registry;validator;progressTracker;nodeIOManager;executionStrategies;executionManager;workflowTimeout=3e5;constructor(){this.registry=nodes_1.NodeRegistry.getInstance(),this.validator=new WorkflowValidator_1.WorkflowValidator,this.progressTracker=new ProgressTracker_1.ProgressTracker,this.nodeIOManager=new NodeIOManager_1.NodeIOManager,this.executionStrategies=new ExecutionStrategies_1.ExecutionStrategies(this.nodeIOManager,this.progressTracker),this.executionManager=new ExecutionManager_1.ExecutionManager(this.progressTracker)}async executeWorkflowAsync(e,r,t,o={}){this.executeWorkflow(e,r,t,o).catch(e=>{logger_1.logger.error("Background workflow execution error:",e)})}async executeWorkflow(e,r,t,o={}){const s=o.executionId||`exec_${Date.now()}_${Math.random().toString(36).substring(2,9)}`,n=new AbortController,a={workflowId:e.id,executionId:s,status:"pending",startTime:new Date,nodeResults:new Map,nodeStatuses:new Map,progress:0};let i;this.executionManager.createExecution(s,a),this.executionManager.registerActiveExecution(s,n);let c=!1;if(o.timeout||this.workflowTimeout){const e=o.timeout||this.workflowTimeout;i=setTimeout(()=>{logger_1.logger.warn(`Workflow ${s} timed out after ${e}ms`),c=!0,a.status="failed",a.error="Workflow execution timed out",n.abort()},e)}try{a.status="running",this.validator.validateWorkflow(e);const i=this.executionManager.getNodeInstances(s);for(const r of e.nodes){try{const e=this.registry.createNode({id:r.id,type:r.type,label:r.label,parameters:r.parameters});i.set(r.id,e)}catch(e){throw logger_1.logger.error(`[WORKFLOW] Failed to create node ${r.id} of type ${r.type}:`,e),new Error(`Cannot create node ${r.id}: Node type '${r.type}' not found. Available types: ${Array.from(this.registry.getNodeTypes()).join(", ")}`)}a.nodeStatuses.set(r.id,{nodeId:r.id,state:nodes_1.NodeState.IDLE,progress:0})}const u=this.validator.buildExecutionOrder(e),g={executionOrder:u,workflow:e,nodeInstances:i,nodeOutputs:new Map,initialInput:r,context:t,result:a,options:o,signal:n.signal};o.parallel?await this.executionStrategies.executeParallel(g):await this.executionStrategies.executeSequential(g),n.signal.aborted||c||(a.status="completed",a.progress=100,o.onProgress&&o.onProgress(s,100,a.nodeStatuses),this.progressTracker.sendExecutionComplete(s,"completed",void 0,a.nodeResults)),a.endTime=new Date}catch(e){if(logger_1.logger.error(`[WORKFLOW ${s}] Failed with error:`,e),n.signal.aborted&&!c)a.status="cancelled",a.error=a.error||"Workflow cancelled by user";else if(!c){const r=e instanceof Error?e.message:"Unknown error";r.toLowerCase().includes("memory")&&logger_1.logger.error(`[WORKFLOW ${s}] Memory exhaustion detected`,{error:r,executionId:s}),e instanceof Error&&(logger_1.logger.error("Error stack:",e.stack),logger_1.logger.error("Error details:",{message:e.message,name:e.name,nodeId:e.nodeId,executionId:s})),a.status="failed",a.error=r}a.endTime=new Date,this.progressTracker.sendExecutionComplete(s,a.status,a.error)}finally{i&&clearTimeout(i),await this.cleanupNodeResources(s),this.executionManager.cleanupExecution(s)}return a}getExecutionResult(e){return this.executionManager.getExecutionResult(e)}cancelExecution(e){return this.executionManager.cancelExecution(e)}getExecutionStatus(e){return this.executionManager.getExecutionStatus(e)}getActiveExecutions(){return this.executionManager.getActiveExecutions()}async cleanupNodeResources(e){const r=this.executionManager.getNodeInstances(e);if(!r)return;const t=[];for(const[e,o]of r)t.push(o.cleanup().catch(r=>{logger_1.logger.error(`Failed to cleanup node ${e}:`,r)}));await Promise.all(t);for(const[e]of r)this.registry.removeNode(e)}}exports.WorkflowExecutor=WorkflowExecutor;