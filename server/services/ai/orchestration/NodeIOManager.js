"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.NodeIOManager=void 0;const DataTransformer_1=require("../../nodes/DataTransformer"),logger_1=require("../../../utils/logger");class NodeIOManager{dataTransformer;constructor(){this.dataTransformer=new DataTransformer_1.DataTransformer}async gatherAndTransformInputs(e,r,t,a,o){const s={},n=r.edges.filter(r=>r.target===e),i=r.nodes.find(r=>r.id===e);if(this.extractNodeParameters(i,e,s),logger_1.logger.debug(`[WORKFLOW] Node ${e} has ${n.length} incoming edges`),0===n.length)return logger_1.logger.debug(`[WORKFLOW] Node ${e} using initial input (no dependencies)`),{...a,...s};for(const r of n)await this.processEdge(r,e,t,o,s,n);return s}async transformValue(e,r){const t=this.dataTransformer.detectDataType(e);return this.dataTransformer.transform(e,t,r)}extractNodeParameters(e,r,t){if(e){if(logger_1.logger.debug(`[WORKFLOW] Extracting parameters for node ${r} (type: ${e.type}):`,{hasParameters:!!e.parameters,parameters:e.parameters}),e.parameters){if(this.isMediaGenerationNode(e.type)&&e.parameters.mediaModel){const modelId=e.parameters.mediaModel;t.model=modelId,logger_1.logger.debug(`[WORKFLOW] Using media model ${modelId} for ${e.type} node ${r}`)}"editing"===e.type&&logger_1.logger.debug("[WORKFLOW] Editing node parameters before copy:",e.parameters),Object.assign(t,e.parameters),"editing"===e.type&&logger_1.logger.debug("[WORKFLOW] Editing node inputs after parameter copy:",t)}if("data"in e&&e.data?.modelId){const modelId=e.data?.modelId;modelId&&(t.model=modelId)}}}isMediaGenerationNode(e){return["image_generation","video_generation","imageGeneration","videoGeneration"].includes(e)}async processEdge(e,r,t,a,o,s){logger_1.logger.debug(`\nüìä [WORKFLOW] Processing edge ${e.id}: ${e.source} ‚Üí ${r}`);const n=t.get(e.source);if(!n)return void logger_1.logger.debug(`‚ö†Ô∏è [WORKFLOW] WARNING: No output available from source node ${e.source}`);this.logVideoGenerationDebug(r,e.source,n);const i=e.data?.sourcePort||e.sourceHandle,g=e.data?.targetPort||e.targetHandle;i&&g?await this.mapSpecificPorts(n,i,g,a,o):await this.mapPortsIntelligently(e,n,a,o,s)}logVideoGenerationDebug(e,r,t){if(e.includes("video")&&r.includes("image")){const e=t.images,r=Array.isArray(e)?e.length:0;logger_1.logger.debug(`[WORKFLOW] Video node receiving ${r} images from image node`)}}async mapSpecificPorts(e,r,t,a,o){const s=e[r];if(logger_1.logger.debug(`[WORKFLOW] Mapping port ${r} ‚Üí ${t}`,{hasValue:void 0!==s,valueType:typeof s,isScript:"script"===r,scriptKeys:"script"===r&&s?Object.keys(s):[],targetNodeType:a.getType()}),void 0!==s){const e=a.getInputPort(t);if(e){const r=await this.transformValue(s,e.type);o[t]=r}}}async mapPortsIntelligently(e,r,t,a,o){const s=t.getInputPorts();for(const e of s){const t=e.name;void 0!==r[t]&&(a[t]=r[t])}0===Object.keys(a).length&&1===o.length&&Object.assign(a,r)}}exports.NodeIOManager=NodeIOManager;