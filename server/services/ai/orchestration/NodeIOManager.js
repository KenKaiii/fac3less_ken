"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.NodeIOManager=void 0;const DataTransformer_1=require("../../nodes/DataTransformer");const logger_1=require("../../../utils/logger");class NodeIOManager{dataTransformer;constructor(){this.dataTransformer=new DataTransformer_1.DataTransformer}async gatherAndTransformInputs(e,r,t,o,a){const n={};const s=r.edges.filter(r=>r.target===e);const i=r.nodes.find(r=>r.id===e);this.extractNodeParameters(i,e,n);logger_1.logger.debug(`[WORKFLOW] Node ${e} has ${s.length} incoming edges`);if(0===s.length){logger_1.logger.debug(`[WORKFLOW] Node ${e} using initial input (no dependencies)`);return{...o,...n}}for(const r of s)await this.processEdge(r,e,t,a,n,s);return n}async transformValue(e,r){const t=this.dataTransformer.detectDataType(e);return this.dataTransformer.transform(e,t,r)}extractNodeParameters(e,r,t){if(!e)return;if(e.parameters){if(this.isMediaGenerationNode(e.type)&&e.parameters.mediaModel){const o=e.parameters.mediaModel;t.model=o;logger_1.logger.debug(`[WORKFLOW] Using media model ${o} for ${e.type} node ${r}`)}Object.assign(t,e.parameters)}if("data"in e&&e.data?.modelId){const r=e.data?.modelId;if(r)t.model=r}}isMediaGenerationNode(e){return["image_generation","video_generation","imageGeneration","videoGeneration"].includes(e)}async processEdge(e,r,t,o,a,n){logger_1.logger.debug(`\nüìä [WORKFLOW] Processing edge ${e.id}: ${e.source} ‚Üí ${r}`);const s=t.get(e.source);if(!s){logger_1.logger.debug(`‚ö†Ô∏è [WORKFLOW] WARNING: No output available from source node ${e.source}`);return}this.logVideoGenerationDebug(r,e.source,s);const i=e.data?.sourcePort||e.sourceHandle;const g=e.data?.targetPort||e.targetHandle;if(i&&g)await this.mapSpecificPorts(s,i,g,o,a);else await this.mapPortsIntelligently(e,s,o,a,n)}logVideoGenerationDebug(e,r,t){if(e.includes("video")&&r.includes("image")){const e=t.images;const r=Array.isArray(e)?e.length:0;logger_1.logger.debug(`[WORKFLOW] Video node receiving ${r} images from image node`)}}async mapSpecificPorts(e,r,t,o,a){const n=e[r];if(void 0!==n){const e=o.getInputPort(t);if(e){const r=await this.transformValue(n,e.type);a[t]=r}}}async mapPortsIntelligently(e,r,t,o,a){const n=t.getInputPorts();for(const e of n){const t=e.name;if(void 0!==r[t])o[t]=r[t]}if(0===Object.keys(o).length&&1===a.length)Object.assign(o,r)}}exports.NodeIOManager=NodeIOManager;