"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.AudioGenerationNode=void 0;const BaseNode_1=require("./BaseNode");const DataTypes_1=require("./DataTypes");const MinimaxTTS_1=require("../../ai/tts/MinimaxTTS");const fs_1=require("fs");const uuid_1=require("uuid");const FileCleanupService_1=require("../../utils/FileCleanupService");const logger_1=require("../../../utils/logger");class AudioGenerationNode extends BaseNode_1.BaseNode{minimaxTTSClient=null;outputDir;constructor(e){super({...e,type:"audio_generation"});if(process.env.REPLICATE_API_TOKEN)this.minimaxTTSClient=new MinimaxTTS_1.MinimaxTTSClient;this.outputDir=process.env.AUDIO_OUTPUT_DIR??"./output/audio"}defineDefaultPorts(){return{inputs:[{name:"script",type:DataTypes_1.DataType.SCRIPT,description:"Script data with sections to convert to speech",required:true},{name:"voice",type:DataTypes_1.DataType.TEXT,description:"Voice selection from MiniMax TTS",required:false,defaultValue:"Friendly_Person"},{name:"pitch",type:DataTypes_1.DataType.NUMBER,description:"Voice pitch adjustment (-2 to 2)",required:false,defaultValue:0,validator:e=>"number"===typeof e&&e>=-2&&e<=2},{name:"speed",type:DataTypes_1.DataType.NUMBER,description:"Speech speed (0.5 - 2.0)",required:false,defaultValue:1,validator:e=>"number"===typeof e&&e>=.5&&e<=2},{name:"outputPath",type:DataTypes_1.DataType.TEXT,description:"Custom output path for audio file",required:false}],outputs:[{name:"audioFiles",type:DataTypes_1.DataType.ARRAY,description:"Array of generated audio files (one per section)"},{name:"totalDuration",type:DataTypes_1.DataType.NUMBER,description:"Total audio duration in seconds"},{name:"transcripts",type:DataTypes_1.DataType.ARRAY,description:"Array of transcripts (one per section)"}]}}async execute(e,t){try{if(!e.script?.scenes)throw new Error("No script data provided for audio generation");const t=String(e.voice??this.config.parameters?.voice??"Friendly_Person");const i=Number(e.pitch??this.config.parameters?.pitch??0);const r=Number(e.speed??this.config.parameters?.speed??1);this.updateProgress(10);await fs_1.promises.mkdir(this.outputDir,{recursive:true});const o=[];const a=[];let n=0;const s=e.script.scenes;const c=80/s.length;for(let e=0;e<s.length;e++){const u=s[e];let d=u.audioPrompt??u.text??"";d=this.sanitizeSectionText(d,e);if(!d)continue;const p=10+e*c;this.updateProgress(p);if(!this.minimaxTTSClient)throw new Error("MiniMax TTS client not initialized. Check API token configuration.");try{const s=await this.generateAudioForSection(d,t,i,r,e,u);o.push(s);a.push(d);if(s.duration)n+=s.duration}catch(n){const s=this.createErrorAudioData(d,t,i,r,e,u,n);o.push(s);a.push(d)}this.updateProgress(10+(e+1)*c)}const u=FileCleanupService_1.FileCleanupService.getInstance();await u.triggerCleanup(this.outputDir);this.updateProgress(100);return{success:true,data:{audioFiles:o,totalDuration:n,transcripts:a},metadata:{nodeId:this.config.id,provider:"minimax-speech-02-hd",voice:t,pitch:i,speed:r,sectionCount:o.length}}}catch(e){return{success:false,error:e instanceof Error?e.message:"Failed to generate audio"}}}validateCustom(e){const t=e;if(!t.script)return"Script is required for audio generation";if(!t.script.scenes||0===t.script.scenes.length)return"Script must contain at least one scene";if(t.voice&&!MinimaxTTS_1.MINIMAX_VOICES[t.voice])return`Invalid voice. Must be one of: ${Object.keys(MinimaxTTS_1.MINIMAX_VOICES).join(", ")}`;return null}sanitizeSectionText(e,t){if(!(e=e.trim())){logger_1.logger.warn(`[AudioGenerationNode] Section ${t+1} has no text, skipping`);return""}const i=e.split(/\s+/).filter(e=>e.length>0).length;if(i<3){logger_1.logger.warn(`[AudioGenerationNode] Section ${t+1} has only ${i} words (min: 3), using fallback`);e=`Section ${t+1} content. ${e}`}if(!(e=e.replace(/[\u{0000}-\u{001F}\u{007F}-\u{009F}]/gu,"").replace(/[<>{}[\]\\]/g,"").replace(/\s+/g," ").trim())||e.length<10){logger_1.logger.error(`[AudioGenerationNode] Section ${t+1} text too short after sanitization, using fallback`);e=`Audio content for section ${t+1}.`}return e}async generateAudioForSection(e,t,i,r,o,a){const n=await this.minimaxTTSClient.textToSpeech({text:e,voice_id:t,pitch:i,speed:r});if(!n.success||!n.data){logger_1.logger.error(`[AudioGenerationNode] Failed to generate audio for section ${o+1}: ${n.error}`);logger_1.logger.error(`[AudioGenerationNode] Failed text was: "${e}"`);return this.createErrorAudioData(e,t,i,r,o,a,new Error(n.error??"Failed to generate audio"))}const s=`audio_section_${o+1}_${(0,uuid_1.v4)()}.wav`;const c=await this.minimaxTTSClient.saveAudioToFile(n.data.audio,s);return{path:c,mimeType:"audio/wav",size:(await fs_1.promises.stat(c)).size,duration:n.data.duration,sampleRate:n.data.sampleRate,channels:n.data.channels,format:n.data.format,metadata:{voice:t,pitch:i,speed:r,provider:"minimax-speech-02-hd",sectionIndex:o+1,sectionText:e}}}createErrorAudioData(e,t,i,r,o,a,n){logger_1.logger.error(`[AudioGenerationNode] Error processing section ${o+1}:`,n);logger_1.logger.error(`[AudioGenerationNode] Section text that failed: "${e}"`);return{path:"",mimeType:"audio/wav",size:0,duration:a.duration??5,sampleRate:22050,channels:1,format:"wav",metadata:{voice:t,pitch:i,speed:r,provider:"minimax-speech-02-hd",sectionIndex:o+1,sectionText:e,error:n instanceof Error?n.message:"Unknown error"}}}}exports.AudioGenerationNode=AudioGenerationNode;