"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,i,o){if(void 0===o)o=i;var a=Object.getOwnPropertyDescriptor(t,i);if(!a||("get"in a?!t.__esModule:a.writable||a.configurable))a={enumerable:true,get:function(){return t[i]}};Object.defineProperty(e,o,a)}:function(e,t,i,o){if(void 0===o)o=i;e[o]=t[i]});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e.default=t});var __importStar=this&&this.__importStar||function(){var ownKeys=function(e){ownKeys=Object.getOwnPropertyNames||function(e){var t=[];for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i))t[t.length]=i;return t};return ownKeys(e)};return function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var i=ownKeys(e),o=0;o<i.length;o++)if("default"!==i[o])__createBinding(t,e,i[o]);__setModuleDefault(t,e);return t}}();Object.defineProperty(exports,"__esModule",{value:true});exports.EditingNode=void 0;const BaseNode_1=require("./BaseNode");const DataTypes_1=require("./DataTypes");const path=__importStar(require("path"));const uuid_1=require("uuid");const ffmpeg_service_1=require("../../ffmpeg.service");const child_process_1=require("child_process");const util_1=require("util");const FFmpegCommandBuilder_1=require("../../ffmpeg/FFmpegCommandBuilder");const MediaFileManager_1=require("../../media/MediaFileManager");const MediaAnalyzer_1=require("../../media/MediaAnalyzer");const VideoEffectsService_1=require("../../video/VideoEffectsService");const AudioVideoSyncService_1=require("../../sync/AudioVideoSyncService");const logger_1=require("../../../utils/logger");const execPromise=(0,util_1.promisify)(child_process_1.exec);class EditingNode extends BaseNode_1.BaseNode{outputDir;currentProgress=0;progressWeights={download:15,syncSegments:35,concatenate:30,finalize:15,cleanup:5};ffmpegService;fileManager;mediaAnalyzer;videoEffectsService;audioVideoSyncService;constructor(e){super({...e,type:"editing"});this.outputDir=process.env.EDITED_OUTPUT_DIR||"./output/edited";this.ffmpegService=new ffmpeg_service_1.FFmpegService;this.fileManager=new MediaFileManager_1.MediaFileManager;this.mediaAnalyzer=new MediaAnalyzer_1.MediaAnalyzer(this.ffmpegService);this.videoEffectsService=new VideoEffectsService_1.VideoEffectsService(this.mediaAnalyzer,this.fileManager);this.audioVideoSyncService=new AudioVideoSyncService_1.AudioVideoSyncService(this.mediaAnalyzer,this.fileManager)}defineDefaultPorts(){return{inputs:[{name:"videos",type:DataTypes_1.DataType.ARRAY,description:"Array of video segments from VideoGenerationNode",required:true},{name:"audioFiles",type:DataTypes_1.DataType.ARRAY,description:"Array of audio narrations from AudioGenerationNode",required:true},{name:"transcripts",type:DataTypes_1.DataType.ARRAY,description:"Array of transcripts from AudioGenerationNode",required:true},{name:"outputPath",type:DataTypes_1.DataType.TEXT,description:"Custom output path for the edited video",required:false},{name:"enableWhipZoom",type:DataTypes_1.DataType.BOOLEAN,description:"Apply zoom effect to first video",required:false,defaultValue:false},{name:"zoomDuration",type:DataTypes_1.DataType.NUMBER,description:"Duration of zoom effect in seconds",required:false,defaultValue:.3},{name:"zoomType",type:DataTypes_1.DataType.TEXT,description:"Direction of zoom (in or out)",required:false,defaultValue:"out"},{name:"enableIntroSound",type:DataTypes_1.DataType.BOOLEAN,description:"Add intro sound to first segment",required:false,defaultValue:false},{name:"enableTransitionSounds",type:DataTypes_1.DataType.BOOLEAN,description:"Add transition sounds between segments",required:false,defaultValue:false},{name:"introSoundPath",type:DataTypes_1.DataType.TEXT,description:"Path to intro sound file",required:false,defaultValue:"assets/sounds/intro-whoosh.mp3"},{name:"transitionSoundPath",type:DataTypes_1.DataType.TEXT,description:"Path to transition sound file",required:false,defaultValue:"assets/sounds/whoosh.mp3"},{name:"soundEffectVolume",type:DataTypes_1.DataType.NUMBER,description:"Volume for intro sound effect (0-1)",required:false,defaultValue:.8},{name:"transitionSoundVolume",type:DataTypes_1.DataType.NUMBER,description:"Volume for transition sound effects (0-1)",required:false,defaultValue:.6}],outputs:[{name:"editedVideo",type:DataTypes_1.DataType.VIDEO,description:"The final edited video with all segments combined"},{name:"duration",type:DataTypes_1.DataType.NUMBER,description:"Total duration of the edited video in seconds"},{name:"outputPath",type:DataTypes_1.DataType.TEXT,description:"Path to the edited video file"},{name:"adjustedTranscripts",type:DataTypes_1.DataType.ARRAY,description:"Transcripts with adjusted timestamps"}]}}async execute(e,t){const i=this.validateCustom(e);if(i)return{success:false,error:i};logger_1.logger.info("[EditingNode] Starting video editing process");try{this.currentProgress=0;await this.updateProgress(this.currentProgress,"Starting video editing");const t=(0,uuid_1.v4)();const i=await this.setupWorkspace(t);await this.updateProgress(5,"Downloading files");const{videoPaths:o,audioPaths:a}=await this.downloadMediaFiles(e,i);await this.updateProgress(this.progressWeights.download,"Files downloaded");await this.applyZoomEffectIfEnabled(e,o,i);const{processedPaths:n,syncSegments:s}=await this.syncAudioVideo(a,o,i);await this.applyIntroSoundIfEnabled(e,n,i);const r=await this.concatenateProcessedSegments(e,n,i);return{success:true,data:await this.finalizeOutput(e,r,s,t,i)}}catch(e){logger_1.logger.error("[EditingNode] Error during video editing:",e);if(e instanceof Error){if(e.message.includes("ENOSPC"))return{success:false,error:"Insufficient disk space for video editing"};if(e.message.includes("ffmpeg")||e.message.includes("FFmpeg"))logger_1.logger.error("[EditingNode] FFmpeg error details:",e.message)}return{success:false,error:e instanceof Error?e.message:"Failed to edit video"}}}async getMediaDuration(e){return this.mediaAnalyzer.getMediaDuration(e)}async setupWorkspace(e){const t=await this.fileManager.createTempDirectory(this.outputDir,`temp_${e}`);await this.fileManager.ensureDirectory(this.outputDir);return t}async downloadMediaFiles(e,t){return{videoPaths:await this.fileManager.downloadFiles(e.videos.map(e=>e.video.path),t,"video"),audioPaths:await this.fileManager.downloadFiles(e.audioFiles.map(e=>e.path),t,"audio")}}async applyZoomEffectIfEnabled(e,t,i){if(e.enableWhipZoom&&t.length>0){const o=e.zoomDuration||.3;const a=e.zoomType||"out";const n=path.join(i,"video_1_zoomed.mp4");logger_1.logger.info(`[EditingNode] Applying zoom effect: duration=${o}s, type=${a}`);const s=await this.videoEffectsService.applyWhipZoom({videoPath:t[0],outputPath:n,zoomDuration:o,zoomType:a});t[0]=s;logger_1.logger.info(`[EditingNode] Zoom effect applied to first video: ${t[0]}`)}else logger_1.logger.info(`[EditingNode] Zoom effect skipped: enableWhipZoom=${e.enableWhipZoom}, videoPaths.length=${t.length}`)}async syncAudioVideo(e,t,i){logger_1.logger.info("[EditingNode] Starting smart audio-video sync");const o=await this.audioVideoSyncService.smartAudioVideoSync(e,t,i);await this.updateProgress(this.progressWeights.download+this.progressWeights.syncSegments,"Segments synced");return o}async applyIntroSoundIfEnabled(e,t,i){if(e.enableIntroSound&&t.length>0){const o=e.introSoundPath||"assets/sounds/intro-whoosh.mp3";const a=e.soundEffectVolume||.6;const n=path.join(i,"synced_segment_0_intro.mp4");logger_1.logger.info(`[EditingNode] Adding intro sound: path=${o}, volume=${a}`);const s=await this.videoEffectsService.addIntroSound({videoPath:t[0],introSoundPath:o,outputPath:n,soundVolume:a});t[0]=s;logger_1.logger.info(`[EditingNode] Intro sound added to first segment: ${t[0]}`)}else logger_1.logger.info(`[EditingNode] Intro sound skipped: enableIntroSound=${e.enableIntroSound}, processedPaths.length=${t.length}`)}async concatenateProcessedSegments(e,t,i){let o;if(e.enableTransitionSounds&&t.length>1){const a=e.transitionSoundPath||"assets/sounds/whoosh.mp3";const n=e.transitionSoundVolume||.6;logger_1.logger.info("[EditingNode] Concatenating segments with transition sounds");o=await this.videoEffectsService.concatenateWithTransitions({segmentPaths:t,transitionSoundPath:a,soundVolume:n,tempDir:i},this.concatenateSegments.bind(this));logger_1.logger.info("[EditingNode] Concatenation with transition sounds complete")}else{logger_1.logger.info("[EditingNode] Concatenating segments without transition sounds");o=await this.concatenateSegments(t,i)}await this.updateProgress(this.progressWeights.download+this.progressWeights.syncSegments+this.progressWeights.concatenate,"Segments concatenated");return o}async finalizeOutput(e,t,i,o,a){const n=`edited_${o}.mp4`;const s=e.outputPath||path.join(this.outputDir,n);await this.fileManager.moveFile(t,s);const r=await this.mediaAnalyzer.getVideoMetadata(s);const d=this.audioVideoSyncService.calculateAdjustedTranscripts(e.transcripts,i);await this.updateProgress(this.progressWeights.download+this.progressWeights.syncSegments+this.progressWeights.concatenate+this.progressWeights.finalize,"Finalizing");await this.fileManager.cleanupDirectory(a);await this.updateProgress(100,"Video editing completed");const c={editedVideo:{path:s,mimeType:"video/mp4",size:(await this.fileManager.getFileStats(s)).size,duration:r.duration,width:r.width,height:r.height,fps:r.fps,format:"mp4"},duration:r.duration,outputPath:s,adjustedTranscripts:d};logger_1.logger.info(`[EditingNode] Video editing completed. Output: ${s}`);return c}async concatenateSegments(e,t){logger_1.logger.info(`[EditingNode] Concatenating ${e.length} segments`);const i=[];let o=0;for(let a=0;a<e.length;a++){const n=e[a];const s=await this.getMediaDuration(n);o+=s;logger_1.logger.debug(`[EditingNode] Segment ${a+1} duration: ${s.toFixed(2)}s`);const r=(await this.mediaAnalyzer.probeMedia(n)).streams.find(e=>"video"===e.codec_type);if(0===a&&n.includes("zoomed")&&r){const e=path.join(t,`normalized_segment_${a}.mp4`);const o=FFmpegCommandBuilder_1.FFmpegCommandBuilder.buildNormalizeCommand(n,e);logger_1.logger.debug(`[EditingNode] Normalizing segment ${a+1} for concatenation`);await execPromise(o);i.push(e)}else i.push(n)}const a=path.join(t,"final_concat.txt");await this.fileManager.createConcatListFile(i,a);logger_1.logger.debug(`[EditingNode] Created concat list with ${i.length} files`);logger_1.logger.debug(`[EditingNode] Expected total duration: ${o.toFixed(2)}s`);const n=path.join(t,"concatenated.mp4");const s=i.every(e=>!e.includes("normalized_segment_"));const r=FFmpegCommandBuilder_1.FFmpegCommandBuilder.buildConcatCommand({concatListPath:a,outputPath:n,canUseCopy:s});logger_1.logger.debug(`[EditingNode] Using ${s?"stream copy":"re-encoding"} for concatenation`);try{logger_1.logger.debug("[EditingNode] Running concatenation command");await execPromise(r);const e=await this.getMediaDuration(n);logger_1.logger.info(`[EditingNode] Concatenation complete. Final video duration: ${e.toFixed(2)}s (expected: ${o.toFixed(2)}s)`);if(Math.abs(e-o)>1)logger_1.logger.warn(`[EditingNode] Duration mismatch after concatenation: expected ${o}s, got ${e}s`)}catch(e){logger_1.logger.error("[EditingNode] Concatenation failed:",e);throw e}await this.fileManager.deleteFile(a);for(const t of i)if(t!==e[i.indexOf(t)]&&t.includes("normalized_segment_"))try{await this.fileManager.deleteFile(t)}catch{}return n}validateCustom(e){const t=e;if(!t.videos||!Array.isArray(t.videos))return"Videos array is required";if(0===t.videos.length)return"At least one video is required";if(!t.audioFiles||!Array.isArray(t.audioFiles))return"Audio files array is required";if(!t.transcripts||!Array.isArray(t.transcripts))return"Transcripts array is required";const i=t.videos.filter(e=>"completed"===e.status).length;const o=t.audioFiles.length;const a=t.transcripts.length;if(i!==o||o!==a)return`Mismatched input counts: ${i} videos, ${o} audio files, ${a} transcripts`;return null}async validateInputs(e){const t=this.validateCustom(e);if(t)throw new Error(t)}async updateProgress(e,t){this.currentProgress=Math.min(100,Math.max(0,e));if(this.emit)this.emit("progress",{nodeId:this.config.id,progress:this.currentProgress,message:t})}async process(e,t){try{await this.validateInputs(e);return await this.execute(e,t)}catch(e){logger_1.logger.error("[EditingNode] Process error:",e);return{success:false,error:e instanceof Error?e.message:"Unknown error occurred"}}}}exports.EditingNode=EditingNode;