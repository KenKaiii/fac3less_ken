"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.VideoGenerationNode=void 0;const BaseNode_1=require("./BaseNode");const DataTypes_1=require("./DataTypes");const ReplicateClient_1=require("../../ai/video/providers/replicate/ReplicateClient");const ai_1=require("../../../../config/ai/index");const logger_1=require("../../../utils/logger");const fs_1=require("fs");class VideoGenerationNode extends BaseNode_1.BaseNode{videoClient=null;outputDir;currentInput;constructor(e){super({...e,type:"video_generation"});const t=ai_1.replicateConfig.apiToken||process.env.REPLICATE_API_TOKEN;logger_1.logger.debug("[VideoGenerationNode] Initializing with API token: "+(t?t.substring(0,10)+"...":"NOT FOUND"));this.videoClient=new ReplicateClient_1.ReplicateClient({apiKey:t||void 0});this.outputDir=process.env.VIDEO_OUTPUT_DIR||"./output/videos"}defineDefaultPorts(){return{inputs:[{name:"images",type:DataTypes_1.DataType.ARRAY,description:"Array of generated images with metadata",required:true},{name:"model",type:DataTypes_1.DataType.TEXT,description:"Video generation model",required:false,defaultValue:"bytedance/seedance-1-lite"},{name:"mode",type:DataTypes_1.DataType.TEXT,description:"Generation mode (standard or pro)",required:false,defaultValue:"standard"},{name:"resolution",type:DataTypes_1.DataType.TEXT,description:"Output video resolution",required:false,defaultValue:"1920x1080"},{name:"aspectRatio",type:DataTypes_1.DataType.TEXT,description:"Video aspect ratio",required:false,defaultValue:"16:9"},{name:"fps",type:DataTypes_1.DataType.NUMBER,description:"Frames per second",required:false,defaultValue:24},{name:"outputPath",type:DataTypes_1.DataType.TEXT,description:"Custom output path for videos",required:false},{name:"videoPrompt",type:DataTypes_1.DataType.TEXT,description:"Universal prompt for video generation motion",required:false,defaultValue:"subtle motion, gentle movement, smooth animation, cinematic quality"},{name:"visualStyle",type:DataTypes_1.DataType.TEXT,description:"Visual style for motion adaptation",required:false}],outputs:[{name:"videos",type:DataTypes_1.DataType.ARRAY,description:"Array of generated video segments"},{name:"totalDuration",type:DataTypes_1.DataType.NUMBER,description:"Total duration of all videos in seconds"},{name:"totalCost",type:DataTypes_1.DataType.NUMBER,description:"Total cost of video generation"}]}}validateVideoClient(){if(!this.videoClient)throw new Error("Video client not initialized. Check API token configuration.")}validateImageInputs(e){if(!e||0===e.length)throw new Error("Images are required for video generation")}prepareVideoParameters(e){const t=e.model||"bytedance/seedance-1-lite";logger_1.logger.info(`[VideoGenerationNode] Using video model: ${t} (from input: ${e.model})`);const o=e.mode||"standard";const i=e.resolution||(t.includes("lite")?"720p":"1920x1080");let a=e.aspectRatio||"16:9";if(!["1:1","16:9","9:16","4:3","3:4"].includes(a)){logger_1.logger.warn(`[VideoGenerationNode] Invalid aspect ratio "${a}", defaulting to 16:9`);a="16:9"}return{model:t,mode:o,resolution:i,aspectRatio:a,fps:e.fps||24,videoPrompt:e.videoPrompt||"subtle motion, gentle movement, smooth animation, cinematic quality"}}createFailedVideoResult(e,t,o,i,a){const[s,r]=o.includes("x")?o.split("x").map(e=>parseInt(e)):"720p"===o?[1280,720]:[1920,1080];return{sectionId:e,video:{path:"",mimeType:"video/mp4",size:0,duration:t.duration,width:s,height:r,fps:i,format:"mp4"},duration:t.duration,status:"failed",error:a}}createSuccessfulVideoResult(e,t,o,i){const[a,s]=i.resolution.includes("x")?i.resolution.split("x").map(e=>parseInt(e)):"720p"===i.resolution?[1280,720]:[1920,1080];return{sectionId:e,video:{path:o,mimeType:"video/mp4",size:0,duration:t.duration,width:a,height:s,fps:i.fps,format:"mp4",metadata:{sectionId:e,model:i.model,prompt:i.videoPrompt,sourceImage:t.image.path}},duration:t.duration,status:"completed"}}validateImageUrl(e){if(!e.image.path||""===e.image.path)throw new Error(`Image path is empty for section ${e.sectionId}`);if(!(e.image.path.startsWith("http://")||e.image.path.startsWith("https://"))){logger_1.logger.error(`[VideoGenerationNode] Image path is not a valid URL for section ${e.sectionId}: "${e.image.path}"`);throw new Error(`Invalid image URL for section ${e.sectionId}: ${e.image.path}`)}}async submitVideoJob(e,t,o=false,i){try{logger_1.logger.debug(`[VideoGenerationNode] Image data for section ${e.sectionId}:`,{path:e.image.path,hasPath:!!e.image.path,mimeType:e.image.mimeType,width:e.image.width,height:e.image.height});this.validateImageUrl(e);this.validateVideoClient();const a=this.enhanceVideoPrompt(t.videoPrompt,o,e,i);if(o)logger_1.logger.info("[VideoGenerationNode] ðŸŽ¯ Using enhanced hook motion for first video:",{sectionId:e.sectionId,originalPrompt:t.videoPrompt.substring(0,50)+"...",enhancedPrompt:a.substring(0,100)+"...",visualStyle:i});logger_1.logger.info("[VideoGenerationNode] Submitting video generation job:",{model:t.model,sectionId:e.sectionId,imagePath:e.image.path,duration:e.duration,resolution:t.resolution,aspectRatio:t.aspectRatio});const s=await this.videoClient.generateVideo({model:t.model,prompt:a,duration:e.duration,startImage:e.image.path,mode:t.mode,resolution:t.resolution,aspectRatio:t.aspectRatio});logger_1.logger.info(`[VideoGenerationNode] generateVideo API response for section ${e.sectionId}:`,{success:s.success,hasData:!!s.data,jobId:s.data?.id,status:s.data?.status,error:s.error,metadata:s.metadata});if(s.success&&s.data){logger_1.logger.debug("[VideoGenerationNode] Job submitted successfully:",{sectionId:e.sectionId,jobId:s.data.id,status:s.data.status,cost:s.metadata?.cost});return{jobId:s.data.id,cost:s.metadata?.cost||0}}else{logger_1.logger.error(`[VideoGenerationNode] Job submission FAILED for section ${e.sectionId}:`,{error:s.error,fullResult:s});return null}}catch(t){logger_1.logger.error(`[VideoGenerationNode] Failed to submit job for section ${e.sectionId}:`,t);throw t}}async checkJobStatus(e,t){try{const o=await this.videoClient.checkStatus(e.jobId);logger_1.logger.debug(`[VideoGenerationNode] checkStatus response for job ${e.jobId}:`,{success:o.success,hasData:!!o.data,status:o.data?.status,hasVideoUrl:!!o.data?.videoUrl,videoUrl:o.data?.videoUrl,progress:o.data?.progress,error:o.data?.error||o.error});if(o.success&&o.data){const t=o.data;if("completed"===t.status&&t.videoUrl){logger_1.logger.debug(`[VideoGenerationNode] Video completed for section ${e.sectionId}:`,{videoUrl:t.videoUrl,jobId:e.jobId});return"completed"}else if("failed"===t.status)return"failed";else{logger_1.logger.debug(`[VideoGenerationNode] Job ${e.jobId} status: ${t.status}, progress: ${t.progress}%`);return"processing"}}else{const o=t.get(e.jobId)||0;if(o<3){t.set(e.jobId,o+1);logger_1.logger.warn(`[VideoGenerationNode] Status check failed for job ${e.jobId}, retry ${o+1}/3`);return"processing"}else return"failed"}}catch(o){logger_1.logger.error(`[VideoGenerationNode] Error checking status for job ${e.jobId}:`,o);const i=t.get(e.jobId)||0;if(i<3){t.set(e.jobId,i+1);return"processing"}else return"failed"}}async execute(e,t){logger_1.logger.debug("ðŸš¨ðŸš¨ðŸš¨ [VideoGenerationNode] EXECUTE CALLED! ðŸš¨ðŸš¨ðŸš¨");try{this.currentInput=e;this.logInputDetails(e);this.validateImageInputs(e.images);logger_1.logger.info(`[VideoGenerationNode] Processing ${e.images.length} images into videos`);logger_1.logger.debug("[VideoGenerationNode] Image details:",{count:e.images.length,images:e.images.map((e,t)=>({index:t,sectionId:e.sectionId,hasImage:!!e.image,imagePath:e.image?.path,duration:e.duration}))});this.updateProgress(10);await fs_1.promises.mkdir(this.outputDir,{recursive:true});const t=this.prepareVideoParameters(e);const o=[];let i=0;const a=await this.submitAllJobs(e.images,t,o);i=a.totalCost;if(a.jobs.length>0)await this.pollForCompletion(a.jobs,o,t);this.handleTimedOutJobs(a.jobs,o,t);const s=o.reduce((e,t)=>e+t.duration,0);const r=o.filter(e=>"completed"===e.status).length;const n=o.filter(e=>"failed"===e.status).length;this.updateProgress(100);return{success:true,data:{videos:o,totalDuration:s,totalCost:i},metadata:{nodeId:this.config.id,model:t.model,successCount:r,failureCount:n}}}catch(e){return{success:false,error:e instanceof Error?e.message:"Failed to generate videos"}}}logInputDetails(e){logger_1.logger.debug("ðŸŽ¬ [VideoGenerationNode] Received input:",{hasImages:!!e.images,imagesLength:e.images?.length,model:e.model,inputKeys:Object.keys(e)});if(e.images)logger_1.logger.debug("ðŸŽ¬ [VideoGenerationNode] Image details:",e.images.map((e,t)=>({index:t,sectionId:e.sectionId,hasImage:!!e.image,imagePath:e.image?.path,imageKeys:e.image?Object.keys(e.image):[],duration:e.duration})))}async submitAllJobs(e,t,o){const i=[];let a=0;logger_1.logger.debug("[VideoGenerationNode] Phase 1: Submitting video generation jobs...");const s=20/e.length;for(let r=0;r<e.length;r++){const n=e[r];logger_1.logger.debug(`[VideoGenerationNode] Submitting job ${r+1}/${e.length} for section ${n.sectionId}`);try{const e=0===r;const s=await this.submitVideoJob(n,t,e,this.currentInput?.visualStyle);if(s){i.push({sectionId:n.sectionId,jobId:s.jobId,imageData:n});a+=s.cost}else o.push(this.createFailedVideoResult(n.sectionId,n,t.resolution,t.fps,"Failed to submit video generation job"))}catch(e){logger_1.logger.error(`[VideoGenerationNode] Failed to submit job for section ${n.sectionId}:`,e);o.push(this.createFailedVideoResult(n.sectionId,n,t.resolution,t.fps,e instanceof Error?e.message:"Unknown error"))}this.updateProgress(10+(r+1)*s)}return{jobs:i,totalCost:a}}async pollForCompletion(e,t,o){logger_1.logger.debug("[VideoGenerationNode] Phase 2: Polling for video completion...",{jobsCount:e.length,jobs:e.map(e=>({sectionId:e.sectionId,jobId:e.jobId}))});const i=Date.now();const a=new Map;const s="test"===process.env.NODE_ENV?0:3e3;if(s>0){logger_1.logger.debug(`[VideoGenerationNode] Waiting ${s/1e3} seconds before starting to poll...`);await new Promise(e=>setTimeout(e,s))}while(e.length>0&&Date.now()-i<3e5){const i=[];for(const s of e){const e=await this.checkJobStatus(s,a);if("completed"===e){const e=await this.videoClient.checkStatus(s.jobId);if(e.success&&e.data?.videoUrl)t.push(this.createSuccessfulVideoResult(s.sectionId,s.imageData,e.data.videoUrl,o))}else if("failed"===e)t.push(this.createFailedVideoResult(s.sectionId,s.imageData,o.resolution,o.fps,"Video generation failed"));else if("processing"===e)i.push(s);else t.push(this.createFailedVideoResult(s.sectionId,s.imageData,o.resolution,o.fps,"Failed to check video status after 3 retries"))}const s=30+t.length/(t.length+i.length)*60;this.updateProgress(s);e.length=0;e.push(...i);if(e.length>0){logger_1.logger.debug(`[VideoGenerationNode] Waiting for ${e.length} videos to complete...`);await new Promise(e=>setTimeout(e,5e3))}}}handleTimedOutJobs(e,t,o){for(const i of e)t.push(this.createFailedVideoResult(i.sectionId,i.imageData,o.resolution,o.fps,"Video generation timed out"))}validateCustom(e){const t=e;if(!t.images||!Array.isArray(t.images))return"Images array is required for video generation";if(0===t.images.length)return"At least one image is required";for(let e=0;e<t.images.length;e++){const o=t.images[e];if(!o.sectionId||!o.image||!o.duration)return`Image at index ${e} is missing required fields (sectionId, image, duration)`}if(t.mode&&!["standard","pro"].includes(t.mode))return'Mode must be either "standard" or "pro"';if(t.fps&&(t.fps<1||t.fps>120))return"FPS must be between 1 and 120";return null}analyzeImageContext(e){const t=e.toLowerCase();if(t.includes("face")||t.includes("person")||t.includes("portrait"))return"slow zoom on subject, subtle camera shake for urgency";if(t.includes("landscape")||t.includes("wide")||t.includes("panoramic"))return"sweeping camera pan revealing scope, atmospheric particles";if(t.includes("object")||t.includes("product")||t.includes("item"))return"rotating orbit reveal, dynamic lighting shift";if(t.includes("text")||t.includes("screen")||t.includes("display"))return"quick zoom to focus, subtle pulse effect";if(t.includes("crowd")||t.includes("group")||t.includes("people"))return"dynamic camera weave through scene, energy building";if(t.includes("close-up")||t.includes("detail")||t.includes("macro"))return"intense push-in with shallow depth, revealing texture";return"forward camera movement with increasing energy"}getStyleMotion(e){return{cinematic:"dramatic dolly zoom, lens flare sweep, depth focus shift",anime:"speed lines effect, dynamic zoom with energy particles",minimalist:"precise geometric camera movement, clean transitions","dark-fantasy":"ominous slow push-in, shadow creep, fog swirl",cyberpunk:"glitch-style micro movements, neon pulse rhythm",retro:"vintage camera shake, film burn effect movement",surreal:"warping perspective shift, dreamlike float",realistic:"handheld camera urgency, documentary-style movement"}[e||""]||"dynamic camera movement"}enhanceVideoPrompt(e,t,o,i){if(!t)return e;const a=this.analyzeImageContext(o?.prompt||"");const s=this.getStyleMotion(i);logger_1.logger.info("[VideoGenerationNode] Enhancing first video prompt:",{originalPrompt:e,imageContext:a,styleAdaptation:s,sectionId:o?.sectionId});return`${a}, ${s}, creating immediate visual interest through movement, \n            energetic but smooth motion that draws viewer attention forward,\n            building anticipation through camera and atmospheric dynamics`}}exports.VideoGenerationNode=VideoGenerationNode;