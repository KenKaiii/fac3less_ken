"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,i,r){if(void 0===r)r=i;var a=Object.getOwnPropertyDescriptor(t,i);if(!a||("get"in a?!t.__esModule:a.writable||a.configurable))a={enumerable:true,get:function(){return t[i]}};Object.defineProperty(e,r,a)}:function(e,t,i,r){if(void 0===r)r=i;e[r]=t[i]});var __setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:true,value:t})}:function(e,t){e.default=t});var __importStar=this&&this.__importStar||function(){var ownKeys=function(e){ownKeys=Object.getOwnPropertyNames||function(e){var t=[];for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i))t[t.length]=i;return t};return ownKeys(e)};return function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var i=ownKeys(e),r=0;r<i.length;r++)if("default"!==i[r])__createBinding(t,e,i[r]);__setModuleDefault(t,e);return t}}();Object.defineProperty(exports,"__esModule",{value:true});exports.FFmpegService=void 0;const child_process_1=require("child_process");const util_1=require("util");const fs=__importStar(require("fs/promises"));const path=__importStar(require("path"));const logger_1=require("../utils/logger");const execPromise=(0,util_1.promisify)(child_process_1.exec);class FFmpegService{tempDir;constructor(){this.tempDir=path.join(process.cwd(),"temp")}async initialize(){await this.ensureTempDir()}async ensureTempDir(){try{await fs.access(this.tempDir)}catch{await fs.mkdir(this.tempDir,{recursive:true})}}async checkFFmpeg(){try{await execPromise("ffmpeg -version");return true}catch{throw new Error("FFmpeg is not installed or not in PATH")}}async concatenateVideos(e,t,i){await this.checkFFmpeg();if(!i){const i=path.join(this.tempDir,`concat_${Date.now()}.txt`);const r=e.map(e=>`file '${e.path}'`).join("\n");await fs.writeFile(i,r);const a=`ffmpeg -f concat -safe 0 -i "${i}" -c copy "${t}" -y`;await execPromise(a);await fs.unlink(i);return t}if(2===e.length)return this.crossfadeTwo(e[0],e[1],t,i);return this.concatenateWithTransitions(e,t,i)}async crossfadeTwo(e,t,i,r){const a=e.duration-r.duration;const o=`ffmpeg -i "${e.path}" -i "${t.path}" -filter_complex "[0:v][1:v]xfade=transition=${r.type}:duration=${r.duration}:offset=${a}[outv];[0:a][1:a]acrossfade=duration=${r.duration}[outa]" -map [outv] -map [outa] "${i}" -y`;await execPromise(o);return i}async concatenateWithTransitions(e,t,i){let r="";let a="0:v";let o="0:a";for(let t=1;t<e.length;t++){const s=e.slice(0,t).reduce((e,t)=>e+t.duration,0)-t*i.duration;r+=`[${a}][${t}:v]xfade=transition=${i.type}:duration=${i.duration}:offset=${s}[v${t}];`;r+=`[${o}][${t}:a]acrossfade=duration=${i.duration}[a${t}];`;a=`v${t}`;o=`a${t}`}const s=`ffmpeg ${e.map(e=>`-i "${e.path}"`).join(" ")} -filter_complex "${r}" -map [${a}] -map [${o}] "${t}" -y`;await execPromise(s);return t}async addAudioTrack(e,t,i,r=true){await this.checkFFmpeg();const a=t.volume||.3;let o="";if(r)o=`-filter_complex "[1:a]volume=${a}[bg];[0:a][bg]amix=inputs=2:duration=first[outa]" -map 0:v -map [outa]`;else o="-map 0:v -map 1:a";const s=`ffmpeg -i "${e}" -i "${t.path}" ${o} -c:v copy "${i}" -y`;await execPromise(s);return i}async addSubtitles(e,t,i,r=true){await this.checkFFmpeg();if(r){const r=t.style||"";const a=r?`:force_style='${r}'`:"";const o=`ffmpeg -i "${e}" -vf "subtitles='${t.path}'${a}" -c:a copy "${i}" -y`;await execPromise(o)}else{const r=`ffmpeg -i "${e}" -i "${t.path}" -c copy -c:s mov_text "${i}" -y`;await execPromise(r)}return i}async generateSubtitlesFromAudio(e,t){throw new Error("Speech-to-text service not implemented. Use external service like Whisper or AssemblyAI")}async encodeVideo(e,t,i={}){await this.checkFFmpeg();const{codec:r="libx264",bitrate:a="2M",resolution:o,fps:s}=i;let n=`ffmpeg -i "${e}"`;if(o)n+=` -vf scale=${o}`;if(s)n+=` -r ${s}`;n+=` -c:v ${r} -b:v ${a} -c:a aac -preset medium "${t}" -y`;await execPromise(n);return t}async extractFrame(e,t,i){await this.checkFFmpeg();const r=`ffmpeg -ss ${t} -i "${e}" -vframes 1 "${i}" -y`;await execPromise(r);return i}async getVideoDuration(e){await this.checkFFmpeg();const t=`ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${e}"`;const{stdout:i}=await execPromise(t);return parseFloat(i.trim())}async getVideoMetadata(videoPath){await this.checkFFmpeg();const command=`ffprobe -v quiet -print_format json -show_format -show_streams "${videoPath}"`;const{stdout:stdout}=await execPromise(command);const info=JSON.parse(stdout);const videoStream=info.streams.find(e=>"video"===e.codec_type);const duration=parseFloat(info.format.duration||"0");return{duration:duration,width:videoStream?.width||1280,height:videoStream?.height||720,fps:videoStream?.r_frame_rate?eval(videoStream.r_frame_rate):30}}async addWatermark(e,t,i,r="bottomright"){await this.checkFFmpeg();const a=`ffmpeg -i "${e}" -i "${t}" -filter_complex "overlay=${{topleft:"10:10",topright:"W-w-10:10",bottomleft:"10:H-h-10",bottomright:"W-w-10:H-h-10"}[r]}" -c:a copy "${i}" -y`;await execPromise(a);return i}async createVideoFromImages(e,t,i=5,r){await this.checkFFmpeg();const a=[];for(let t=0;t<e.length;t++){const r=path.join(this.tempDir,`img_video_${t}_${Date.now()}.mp4`);const o=`ffmpeg -loop 1 -i "${e[t]}" -c:v libx264 -t ${i} -pix_fmt yuv420p "${r}" -y`;await execPromise(o);a.push({path:r,duration:i})}const o=await this.concatenateVideos(a,t,r);for(const e of a)await fs.unlink(e.path);return o}async cleanup(){try{const e=await fs.readdir(this.tempDir);for(const t of e)await fs.unlink(path.join(this.tempDir,t))}catch(e){logger_1.logger.error("Cleanup error:",e)}}}exports.FFmpegService=FFmpegService;