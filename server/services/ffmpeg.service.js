"use strict";var __createBinding=this&&this.__createBinding||(Object.create?function(e,t,i,a){void 0===a&&(a=i);var r=Object.getOwnPropertyDescriptor(t,i);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[i]}}),Object.defineProperty(e,a,r)}:function(e,t,i,a){void 0===a&&(a=i),e[a]=t[i]}),__setModuleDefault=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),__importStar=this&&this.__importStar||function(){var ownKeys=function(e){return ownKeys=Object.getOwnPropertyNames||function(e){var t=[];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(t[t.length]=i);return t},ownKeys(e)};return function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var i=ownKeys(e),a=0;a<i.length;a++)"default"!==i[a]&&__createBinding(t,e,i[a]);return __setModuleDefault(t,e),t}}();Object.defineProperty(exports,"__esModule",{value:!0}),exports.FFmpegService=void 0;const child_process_1=require("child_process"),util_1=require("util"),fs=__importStar(require("fs/promises")),path=__importStar(require("path")),logger_1=require("../utils/logger"),execPromise=(0,util_1.promisify)(child_process_1.exec);class FFmpegService{tempDir;constructor(){this.tempDir=path.join(process.cwd(),"temp")}async initialize(){await this.ensureTempDir()}async ensureTempDir(){try{await fs.access(this.tempDir)}catch{await fs.mkdir(this.tempDir,{recursive:!0})}}async checkFFmpeg(){try{return await execPromise("ffmpeg -version"),!0}catch{throw new Error("FFmpeg is not installed or not in PATH")}}async concatenateVideos(e,t,i){if(await this.checkFFmpeg(),!i){const i=path.join(this.tempDir,`concat_${Date.now()}.txt`),a=e.map(e=>`file '${e.path}'`).join("\n");await fs.writeFile(i,a);const r=`ffmpeg -f concat -safe 0 -i "${i}" -c copy "${t}" -y`;return await execPromise(r),await fs.unlink(i),t}return 2===e.length?this.crossfadeTwo(e[0],e[1],t,i):this.concatenateWithTransitions(e,t,i)}async crossfadeTwo(e,t,i,a){const r=e.duration-a.duration,o=`ffmpeg -i "${e.path}" -i "${t.path}" -filter_complex "[0:v][1:v]xfade=transition=${a.type}:duration=${a.duration}:offset=${r}[outv];[0:a][1:a]acrossfade=duration=${a.duration}[outa]" -map [outv] -map [outa] "${i}" -y`;return await execPromise(o),i}async concatenateWithTransitions(e,t,i){let a="",r="0:v",o="0:a";for(let t=1;t<e.length;t++){const s=e.slice(0,t).reduce((e,t)=>e+t.duration,0)-t*i.duration;a+=`[${r}][${t}:v]xfade=transition=${i.type}:duration=${i.duration}:offset=${s}[v${t}];`,a+=`[${o}][${t}:a]acrossfade=duration=${i.duration}[a${t}];`,r=`v${t}`,o=`a${t}`}const s=`ffmpeg ${e.map(e=>`-i "${e.path}"`).join(" ")} -filter_complex "${a}" -map [${r}] -map [${o}] "${t}" -y`;return await execPromise(s),t}async addAudioTrack(e,t,i,a=!0){await this.checkFFmpeg();const r=t.volume||.3;let o="";o=a?`-filter_complex "[1:a]volume=${r}[bg];[0:a][bg]amix=inputs=2:duration=first[outa]" -map 0:v -map [outa]`:"-map 0:v -map 1:a";const s=`ffmpeg -i "${e}" -i "${t.path}" ${o} -c:v copy "${i}" -y`;return await execPromise(s),i}async addSubtitles(e,t,i,a=!0){if(await this.checkFFmpeg(),a){const a=t.style||"",r=a?`:force_style='${a}'`:"",o=`ffmpeg -i "${e}" -vf "subtitles='${t.path}'${r}" -c:a copy "${i}" -y`;await execPromise(o)}else{const a=`ffmpeg -i "${e}" -i "${t.path}" -c copy -c:s mov_text "${i}" -y`;await execPromise(a)}return i}async generateSubtitlesFromAudio(e,t){throw new Error("Speech-to-text service not implemented. Use external service like Whisper or AssemblyAI")}async encodeVideo(e,t,i={}){await this.checkFFmpeg();const{codec:a="libx264",bitrate:r="2M",resolution:o,fps:s}=i;let n=`ffmpeg -i "${e}"`;return o&&(n+=` -vf scale=${o}`),s&&(n+=` -r ${s}`),n+=` -c:v ${a} -b:v ${r} -c:a aac -preset medium "${t}" -y`,await execPromise(n),t}async extractFrame(e,t,i){await this.checkFFmpeg();const a=`ffmpeg -ss ${t} -i "${e}" -vframes 1 "${i}" -y`;return await execPromise(a),i}async getVideoDuration(e){await this.checkFFmpeg();const t=`ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${e}"`,{stdout:i}=await execPromise(t);return parseFloat(i.trim())}async getVideoMetadata(videoPath){await this.checkFFmpeg();const command=`ffprobe -v quiet -print_format json -show_format -show_streams "${videoPath}"`,{stdout:stdout}=await execPromise(command),info=JSON.parse(stdout),videoStream=info.streams.find(e=>"video"===e.codec_type),duration=parseFloat(info.format.duration||"0");return{duration:duration,width:videoStream?.width||1280,height:videoStream?.height||720,fps:videoStream?.r_frame_rate?eval(videoStream.r_frame_rate):30}}async addWatermark(e,t,i,a="bottomright"){await this.checkFFmpeg();const r=`ffmpeg -i "${e}" -i "${t}" -filter_complex "overlay=${{topleft:"10:10",topright:"W-w-10:10",bottomleft:"10:H-h-10",bottomright:"W-w-10:H-h-10"}[a]}" -c:a copy "${i}" -y`;return await execPromise(r),i}async createVideoFromImages(e,t,i=5,a){await this.checkFFmpeg();const r=[];for(let t=0;t<e.length;t++){const a=path.join(this.tempDir,`img_video_${t}_${Date.now()}.mp4`),o=`ffmpeg -loop 1 -i "${e[t]}" -c:v libx264 -t ${i} -pix_fmt yuv420p "${a}" -y`;await execPromise(o),r.push({path:a,duration:i})}const o=await this.concatenateVideos(r,t,a);for(const e of r)await fs.unlink(e.path);return o}async cleanup(){try{const e=await fs.readdir(this.tempDir);for(const t of e)await fs.unlink(path.join(this.tempDir,t))}catch(e){logger_1.logger.error("Cleanup error:",e)}}}exports.FFmpegService=FFmpegService;