"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports.MediaAnalyzer=void 0;const child_process_1=require("child_process");const util_1=require("util");const ffmpeg_service_1=require("../ffmpeg.service");const FFmpegCommandBuilder_1=require("../ffmpeg/FFmpegCommandBuilder");const logger_1=require("../../utils/logger");const execPromise=(0,util_1.promisify)(child_process_1.exec);class MediaAnalyzer{ffmpegService;constructor(e){this.ffmpegService=e||new ffmpeg_service_1.FFmpegService}async getMediaDuration(e){try{return await this.ffmpegService.getVideoDuration(e)}catch{try{const r=FFmpegCommandBuilder_1.FFmpegCommandBuilder.buildDurationProbeCommand(e);const{stdout:t}=await execPromise(r);const i=parseFloat(t.trim());if(isNaN(i)){logger_1.logger.error(`[MediaAnalyzer] Invalid duration for ${e}: ${t}`);throw new Error(`Could not determine duration for ${e}`)}return i}catch(r){logger_1.logger.error(`[MediaAnalyzer] Failed to get duration for ${e}:`,r);throw r}}}async getVideoMetadata(e){try{return await this.ffmpegService.getVideoMetadata(e)}catch{const r=FFmpegCommandBuilder_1.FFmpegCommandBuilder.buildMetadataProbeCommand(e);const{stdout:t}=await execPromise(r);const i=JSON.parse(t);const a=i.streams.find(e=>"video"===e.codec_type);return{duration:parseFloat(i.format.duration||"0"),width:a?.width||1280,height:a?.height||720,fps:this.parseFps(a?.r_frame_rate||"30/1")}}}async probeMedia(e){const r=FFmpegCommandBuilder_1.FFmpegCommandBuilder.buildProbeCommand(e);const{stdout:t}=await execPromise(r);return JSON.parse(t)}async getVideoStreamInfo(e){return(await this.probeMedia(e)).streams.find(e=>"video"===e.codec_type)}async getAudioStreamInfo(e){return(await this.probeMedia(e)).streams.find(e=>"audio"===e.codec_type)}async hasVideoStream(e){return(await this.probeMedia(e)).streams.some(e=>"video"===e.codec_type)}async hasAudioStream(e){return(await this.probeMedia(e)).streams.some(e=>"audio"===e.codec_type)}parseFps(e){if(e.includes("/")){const[r,t]=e.split("/").map(Number);return t>0?r/t:30}return parseFloat(e)||30}async getMultipleMediaDurations(e){return Promise.all(e.map(e=>this.getMediaDuration(e)))}async analyzeCompatibility(e){const r=[];if(0===e.length)return{compatible:true,issues:r};try{const t=(await Promise.all(e.map(e=>this.probeMedia(e)))).map(e=>e.streams.find(e=>"video"===e.codec_type)).filter(Boolean);if(t.length>0){const e=t[0];const i=e?.width;const a=e?.height;const o=e?.r_frame_rate;t.forEach((e,t)=>{if(e?.width!==i||e?.height!==a)r.push(`File ${t+1} has different resolution: ${e?.width}x${e?.height} vs ${i}x${a}`);if(e?.r_frame_rate!==o)r.push(`File ${t+1} has different framerate: ${e?.r_frame_rate} vs ${o}`)})}return{compatible:0===r.length,issues:r}}catch(e){logger_1.logger.error("[MediaAnalyzer] Compatibility analysis failed:",e);return{compatible:false,issues:["Failed to analyze media files"]}}}}exports.MediaAnalyzer=MediaAnalyzer;